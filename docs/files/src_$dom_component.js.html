<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>Documentation: $dom.component@0.1.0</title>
    <link rel="stylesheet" href="../assets/from_yahhoapis/cssgrids-min.css">
<link rel="stylesheet" href="http://yui.yahooapis.com/3.8.0pr2/build/cssgrids/cssgrids-min.css">
    <link rel="stylesheet" href="../assets/vendor/prettify/prettify-min.css">
    <link rel="stylesheet" href="../assets/css/main.css" id="site_styles">
    <script src="../assets/from_yahhoapis/yui-min.js"></script>
</head>
<body class="yui3-skin-sam">

<div id="doc">
    <div id="hd" class="yui3-g header">
        <div class="yui3-u-3-4">
            <h1><a href="../index.html"><img src="../assets/css/logo.png" width="117" height="52">$dom.component</a>: src\$dom_component.js</h1>
        </div>
        <div class="yui3-u-1-4 version">
            <em>API Docs for: 0.1.0</em>
        </div>
    </div>
    <div class="yui3-g">

        <div id="sidebar" class="yui3-u">
            <div id="modules" class="sidebox">
                <div class="hd">
                    <h2 class="no-toc">Modules</h2>
                </div>
                <div class="bd">
                    <ul>
                    </ul>
                </div>
            </div>
            
            <div id="classes" class="sidebox">
                <div class="hd">
                    <h2 class="no-toc">Classes</h2>
                </div>
                <div class="bd">
                    <ul>
                            <li><a href="../classes/$dom.component.html">$dom.component</a></li>
                            <li><a href="../classes/$dom.{namespace}.html">$dom.{namespace}</a></li>
                    </ul>
                </div>
            </div>
            
            <div id="elements" class="sidebox">
                <div class="hd">
                    <h2 class="no-toc">Elements</h2>
                </div>
                <div class="bd">
                    <ul>
                    </ul>
                </div>
            </div>
            
            
            
            
            
            <div id="fileTree" class="sidebox">
                <div class="hd">
                    <h2 class="no-toc">Files</h2>
                </div>
                <div class="bd">
                    <ul><li>src\$dom_component.js/<ul></ul></li></ul>
                </div>
            </div>
            
        </div>

        <div id="main" class="yui3-u">
            <div class="content"><h4>src\$dom_component.js</h4>

<pre class="code prettyprint linenums">
/* jshint esversion: 6,-W097, -W040, browser: true, expr: true, undef: true */
init(window);
function init(global){
    &quot;use strict&quot;;
    /**
     * This NAMESPACE provides features for DOM elemnts.
     * @class $dom.{namespace}
     * @static
     */
    let $dom= {
        /**
         * Procedure removes all children of &#x60;container&#x60;
         * @method empty
         * @param {NodeElement} container
         */
        empty: function(container){
            let len= container.childNodes.length;
            while(len--){ container.removeChild(container.lastChild); }
        },
        /**
         * Procedure places &#x60;new_element&#x60; after &#x60;reference&#x60; elements
         * @method insertAfter
         * @param {NodeElement} new_element
         * @param {NodeElement} reference
         */
        insertAfter: function(new_element, reference){
            const { parentNode, nextSibling }= reference;
            if(nextSibling) parentNode.insertBefore(new_element, nextSibling);
            else parentNode.appendChild(new_element);
        },
        /**
         * Procedure replaces &#x60;el_old&#x60; element by new one (&#x60;new_el&#x60;)
         * @method replace
         * @param {NodeElement} el_old
         * @param {NodeElement} el_new
         */
        replace: function(el_old, el_new){
            $dom.insertAfter(el_new, el_old);
            el_old.remove();
        }
    };
    /**
     * This &#x27;functional class&#x27; is syntax sugar around [&#x60;DocumentFragment&#x60;](https://developer.mozilla.org/en-US/docs/Web/API/DocumentFragment) for creating DOM components and their adding to live DOM in performance friendly way.
     * @class $dom.component
     * @constructor
     * @param {String} el_name
     *  - Name of element (for example &#x60;LI&#x60;, &#x60;P&#x60;, &#x60;A&#x60;, ...).
     *  - This is parent element of component.
     * @param {Object} attrs
     *  - The second argument for [&#x60;$dom.assign&#x60;](./$dom.{namespace}.html#methods_assign)
     * @param {Object} params
     * @param {Function|Boolean} params.mapUpdate
     *  - &#x60;[params.mapUpdate=undefined]&#x60;
     *  - This function (if defined) remap &#x60;update(DATA)&#x60; to varibales used in keys &#x60;attrs.onupdate&#x60; ... see [&#x60;add&#x60;](#methods_add)
     * @return {$dom.component}
     *  - &#x27;functional class instance&#x27;: object &#x60;{ add, component, mount, update, share, onupdate }&#x60;
     *  - &#x60;share&#x60; is Object for transfering methods somewhere else (like for using in another component, see [&#x60;component&#x60;](#methods_component))
     *      - &#x60;share= { mount, update, destroy, isStatic }&#x60;
     *  - &#x60;onupdate&#x60;
     *      - It returns {$dom.component} and it is only one differnece against [&#x60;add&#x60;](#methods_add)
     *      - &#x60;onupdate&#x60; is function which accepts two params &#x60;object, function&#x60;, the function is called during creating element and evry &#x60;update&#x60;calls
     *      - It returns additional &#x60;attrs&#x60;, for example this &#x60;attrs&#x60;: &#x60;$dom.component(&quot;DIV&quot;, { className: &quot;class&quot; }).onupdate({ a }, _=&gt;({ textContent: a }))&#x60; =&gt; final &#x60;attrs= { className: &quot;class&quot;, textContent: &quot;A&quot; }&#x60; (if &#x60;a=&quot;A&quot;&#x60;)
     *      - it use [&#x60;$dom.assign&#x60;](./$dom.{namespace}.html#methods_assign) (**no deep copy!!!**)
     */
    /** */
    $dom.component= function(el_name, attrs, { mapUpdate }={}){
        let /* holds &#x60;initStorage()&#x60; if &#x60;onupdate&#x60; was registered */
            internal_storage= null;
        const /* &#x27;drawer&#x27; (container) for component elements */
            fragment= document.createDocumentFragment();
        let /* main parent (wrapper), container for children elements */
            container,
            /* store for all registered elements */
            els= [], all_els_counter= 0,
            /* current elements deep which holds indicies of elements:
                - add(...);add(...); = final deep=[0,1];
                - add(...);add(...,-1);add(...) = final deep=[1,2]; (by steps: [0], [0,1], [1,2])
                - see &#x60;shift&#x60; in &#x60;add&#x60;
            */
            deep= [];
        const { onupdate }= add(el_name, attrs);
        const share= { mount, update, destroy, isStatic };
        const component_out= { add, component, mount, update, share };
        return Object.assign({}, component_out, { onupdate: function(...attrs){ onupdate(...attrs); return component_out; } });
        /**
         * This add element to component
         * @method add
         * @public
         * @param {String} el_name
         *  - Name of element (for example &#x60;LI&#x60;, &#x60;P&#x60;, &#x60;A&#x60;, ...).
         * @param {Object} attrs
         *  - &#x60;null|undefined&#x60; is also supported (&#x60;null&#x60; is probably recommendet for better readability)
         *  - The second argument for [&#x60;$dom.assign&#x60;](./$dom.{namespace}.html#methods_assign)
         * @param {Number} [shift= 0]
         *  - Modify nesting behaviur. By default (&#x60;shift= 0&#x60;), new element is child of previus element. Every &#x60;-1&#x60; means moving to the upper level against current one - see example.
         * @returns {Object}
         *  - &#x60;getReference&#x60; {Function}: return NodeElement reference of added element
         *  - &#x60;onupdate&#x60;
         *      - Pattern: &#x60;add(...).onupdate(Values: Object, Retuns_attrs_keys: Function)&#x60;
         *      - This register listener/subscriber function (&#x60;Retuns_attrs_keys&#x60;) for keys (variables) in &#x60;Values&#x60;
         *      - Example: &#x60;add(...).onupdate({counter}, _=&gt;({ textContent: counter }))&#x60; registers listerner to &#x60;counter&#x60;. When the &#x60;udate({ ... counter: something, ...})&#x60; is called this element changes &#x60;textContent&#x60;.
         *      - See [&#x60;update&#x60;](#methods_update)
         * @example
         *      //#1
         *      const UL= document.getElementById(&#x27;SOME UL&#x27;);
         *      const { add }= $dom.component(&quot;LI&quot;, { className: &quot;list_item&quot; });//&lt;li class=&quot;list_item&quot;&gt;...&lt;/li&gt;
         *      add(&quot;DIV&quot;, { textContent: &quot;Child of .list_item&quot;, className: &quot;deep1&quot; });//&lt;li class=&quot;list_item&quot;&gt;&lt;div class=&quot;deep1&quot;&gt;...&lt;/div&gt;&lt;/li&gt;
         *          add(&quot;DIV&quot;, { textContent: &quot;Child of div.deep1&quot;, className: &quot;deep2&quot; });//...&lt;div class=&quot;deep1&quot;&gt;&lt;div class=&quot;deep2&quot;&gt;...&lt;/div&gt;&lt;/div&gt;...
         *              add(&quot;DIV&quot;, { textContent: &quot;Child of div.deep2&quot;, className: &quot;deep3&quot; });//...&lt;div class=&quot;deep1&quot;&gt;&lt;div class=&quot;deep2&quot;&gt;&lt;div class=&quot;deep3&quot;&gt;...&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;...
         *              add(&quot;DIV&quot;, { textContent: &quot;Child of div.deep2&quot;, className: &quot;deep3 mark&quot; }, -1);//...&lt;div class=&quot;deep2&quot;&gt;&lt;div class=&quot;deep3&quot;&gt;...&lt;/div&gt;&lt;div class=&quot;deep3&quot;&gt;...&lt;/div&gt;&lt;/div&gt;...
         *      //next add(*) schoul be child of div.deep3.mark, by -1 it is ch.of div.deep2, by -2 ch.of div.deep1, by -3 ch.of li.list_item because div.deep3.mark is on 3rd level
         *          add(&quot;DIV&quot;, { textContent: &quot;Child of div.deep1&quot;, className: &quot;deep2 nextone&quot; }, -2);//this is on 2nd level
         *      add(&quot;DIV&quot;, { textContent: &quot;Child of div.deep1&quot;, className: &quot;deep2 nextone&quot; }, -2);//this is on 0 level
         *          add(&quot;DIV&quot;, null); // just DIV without attributes
         *      ...
         */
        function add(el_name, attrs, shift= 0){
            recalculateDeep(shift);
            attrs= attrs || {};
            const prepare_el= document.createElement(el_name);
            if(!all_els_counter) container= els[0]= fragment.appendChild(prepare_el);
            else els[all_els_counter]= els[getParentIndex()].appendChild(prepare_el);
            let el= els[all_els_counter];
            all_els_counter++;
            $dom.assign(el, attrs);
            return {
                getReference: ()=&gt; el,
                onupdate: function(...attrs){ if(!internal_storage) internal_storage= initStorage(); $dom.assign(el, internal_storage.register(el, ...attrs)); }
            };
        }
        /**
         * Method for including another component by usint its &#x60;share&#x60; key.
         * @method component
         * @public
         * @param {Object} share
         * @param {Number} shift
         *  - see [&#x60;add&#x60;](#methods_add)
         */
        function component({ mount, update, isStatic }, shift= 0){
            recalculateDeep(shift);
            els[all_els_counter]= mount(els[getParentIndex()]);
            if(!isStatic()){
                if(!internal_storage) internal_storage= initStorage();
                internal_storage.registerComponent(update);
            }
            all_els_counter+= 1;
        }
        /**
         * Add element to live DOM
         * @method mount
         * @public
         * @param {NodeElement} element
         *  - Element where to places this component
         * @param {String} [type= &quot;childLast&quot;]
         *  - Change type of mounting
         *  - &#x60;childLast&#x60; places component as last child
         *  - &#x60;childFirst&#x60; places component as first child
         *  - &#x60;replaceContent&#x60; removes content of &#x60;element&#x60; and places component as child (uses &#x60;$dom.empty&#x60;)
         *  - &#x60;replace&#x60; replaces &#x60;element&#x60; by component
         *  - &#x60;before&#x60; places component before &#x60;element&#x60;
         *  - &#x60;after&#x60; places component after &#x60;element&#x60; (uses &#x60;$dom.insertAfter&#x60;)
         */
        function mount(element, type= &quot;childLast&quot;){
            switch ( type ) {
                case &quot;replace&quot;:
                    $dom.replace(element, fragment);
                    break;
                case &quot;replaceContent&quot;:
                    $dom.empty(element);
                    element.appendChild(fragment);
                    break;
                case &quot;before&quot;:
                    element.parentNode.insertBefore(fragment, element);
                    break;
                case &quot;after&quot;:
                    $dom.insertAfter(fragment, element);
                    break;
                default:
                    if(type===&quot;childFirst&quot; &amp;&amp; element.childNodes.length) element.insertBefore(fragment, element.childNodes[0]);
                    else element.appendChild(fragment);
                    break;
            }
            return container;
        }
        /**
         * Method remove element form live DOM and returns null
         * @method destroy
         * @public
         * @example
         *  let { share: test }= $dom.component(&quot;DIV&quot;, null);
         *  test.mount(document.body);
         *  test= test.destroy();
         */
        function destroy(){
            container.remove();
            return null;
        }
        /**
         * Updates &#x60;deep&#x60;
         * @private
         * @method recalculateDeep
         * @param {Number} shift
         *  - see [&#x60;add&#x60;](#methods_add)
         */
        function recalculateDeep(shift){
            if(!shift) deep.push(all_els_counter);
            else { deep.splice(deep.length+1+shift); deep[deep.length-1]= all_els_counter; }
        }
        /**
         * Returns current &#x60;deep&#x60; (last element in array)
         * @method getParentIndex
         * @private
         */
        function getParentIndex(){
            return deep[deep.length-2];
        }
        /**
         * Initialize internal storage
         * @method initStorage
         * @private
         * @returns {Object}
         *  - &#x60;{ register, registerComponent, update, unregister}&#x60;
         */
        function initStorage(){
            const /* storage for component, functions for updates and mapping data keys and corresponding elements */
                data= {},
                components= [], els= new Map(),
                functions= new Map(),
                listeners= new Map();
            let 
                els_counter= 0;
            return {
                register: function(el, init_data, fun){
                    Object.assign(data, init_data);
                    const el_id= els_counter++; els.set(el_id,el);
                    const init_data_keys= Object.keys(init_data);
                    for(let i=0, i_key, i_length= init_data_keys.length; i&lt;i_length; i++){
                        i_key= init_data_keys[i];
                        if(!listeners.has(i_key)) listeners.set(i_key, [ el_id ]);
                        else listeners.set(i_key, [ ...listeners.get(i_key), el_id ]);
                    }
                    functions.set(el_id, fun);
                    return fun.call(el, init_data) || {};
                },
                registerComponent: function(update){
                    if(components.indexOf(update)===-1) components.push(update);
                },
                update: function(new_data_input){
                    const new_data= typeof mapUpdate===&quot;function&quot; ? mapUpdate(new_data_input) : new_data_input;
                    let out= false;
                    for(let i=0, i_length= components.length; i&lt;i_length; i++){ if(components[i](new_data)&amp;&amp;!out){out=true;} }
                    if(!listeners.size) return out;
                    const /* keys to update (subscribers exits and was changed) */
                        new_data_keys= Object.keys(new_data)
                            .filter(key=&gt;listeners.has(key)&amp;&amp;data[key]!==new_data[key]),
                        new_data_keys_length= new_data_keys.length;
                    if(!new_data_keys_length) return out;
                    Object.assign(data, new_data);
                    const els_for_redraw= [];
                    for(let i=0, i_listeners; i&lt;new_data_keys_length; i++){
                        i_listeners= listeners.get(new_data_keys[i]);
                        for(let j=0, ji_listener, j_length= i_listeners.length; j&lt;j_length; j++){
                            ji_listener= i_listeners[j];
                            if(els_for_redraw.indexOf(ji_listener)===-1) els_for_redraw.push(ji_listener);
                        }
                    }
                    for(let i=0, i_length= els_for_redraw.length; i&lt;i_length; i++){ processChanges(els_for_redraw[i]); }
                    return true;
                    
                    function processChanges(el_id){
                        const new_attrs= functions.get(el_id).call(els.get(el_id), data) || {};
                        const el= els.get(el_id);
                        if(el.parentNode===null) return unregister(el_id, new_data_keys);
                        else $dom.assign(el, new_attrs);
                    }
                },
                unregister
            };
            function unregister(el_id, data_keys){
                functions.delete(el_id);
                els.delete(el_id);
                for(let i=0, i_key, listener, i_length= data_keys.length; i&lt;i_length; i++){
                    i_key= data_keys[i];
                    listener= listeners.get(i_key);
                    if(listener.length===1) listeners.delete(i_key);
                    else listeners.set(i_key, listener.filter(el_idFilter));
                }
                function el_idFilter(v){ return v!==el_id; }
            }
        }
        /**
         * Method updates all registered varibles by keys &#x60;onupdates&#x60; and calls follower functions
         * @method update
         * @public
         * @param {Object} new_data
         *  - When &#x60;$dom.component&#x60; is initialized, it is possible to register &#x60;mapUpdate&#x60;
         *  - **It&#x27;s because internally, it is used &#x60;Object.assign&#x60; (no deep copy) to merge new data with older one!!!**
         * @example
         *      const data_A= { a: &quot;A&quot; };
         *      const data_A_update= { a: &quot;AAA&quot; };
         *      const { add, mount, update }= $dom.component(&quot;UL&quot;, null);
         *          add(&quot;LI&quot;, { onupdate: [ { a }, ({ a })=&gt;({ textContent: a }) ] });//&#x60;[ { a },&#x60; add listener for &quot;a&quot;
         *      mount(document.body);
         *      update(data_A_update);
         *      //BUT
         *      const data_B= { a: { b: &quot;A&quot; }};
         *      const data_B_update= { a: { b: &quot;AAA&quot; }};
         *      const { add, mount, update }= $dom.component(&quot;UL&quot;, null, { mapUpdate: d=&gt;({ a: d.a.b }) });
         *          add(&quot;LI&quot;, { onupdate: [ { a: data_B.a.b }, ({ a })=&gt;({ textContent: a }) ] });//&#x60;[ { a },&#x60; add listener for &quot;a&quot;
         *      mount(document.body);
         *      update(data_B_update);
         */
        function update(new_data){
            if(!internal_storage) return false;
            return internal_storage.update(new_data);
        }
        /**
         * Methods returns if it was &#x60;onupdate&#x60; used
         * @method isStatic
         * @public
         * @return {Boolean}
         *  - If there is some listeners &#x60;onupdate&#x60;
         */
        function isStatic(){
            return !internal_storage;
        }
    };
    /**
     * Procedure for merging object into the element properties.
     * Very simple example: &#x60;$dom.assign(document.body, { className: &quot;test&quot; });&#x60; is equivalent to &#x60;document.body.className= &quot;test&quot;;&#x60;.
     * It is not deep copy in general, but it supports &#x60;style&#x60;, &#x60;style_vars&#x60; and &#x60;dataset&#x60; objects (see below).
     * @method assign
     * @for $dom.{namespace}
     * @param {NodeElement} element
     * @param {Object} object_attributes
     *  - Object shall holds **NodeElement** properties like &#x60;className&#x60;, &#x60;textContent&#x60;, ...
     *  - For &#x60;dataset&#x60; can be used also &#x60;Object&#x60; notation: &#x60;$dom.assign(document.getElementById(&quot;ID&quot;), { dataset: { test: &quot;TEST&quot; } }); //&lt;p id=&quot;ID&quot; data-test=&quot;TEST&quot;&gt;&lt;/p&gt;&#x60;.
     *  - The same notation can be used for **CSS variables** (the key is called &#x60;style_vars&#x60;).
     *  - **IMPORTANT CHANGE**: Key &#x60;style&#x60; also supports **text**, so &#x60;$dom.assign(el, { style: &quot;color: red;&quot; });&#x60; and &#x60;$dom.assign(el, { style: { color: &quot;red&quot; } })&#x60; is equivalent to &#x60;el.setAttribute(&quot;style&quot;, &quot;color: red;&quot;);&#x60;
     *  - **IMPORTANT DIFFERENCE**: &#x60;classList&#x60; accepts *Object* in the form of &#x60;class_name: -1|0|1&#x60; where &#x27;-1&#x27; means &#x60;el.classList(class_name)&#x60; others &#x60;el.classList(class_name, Booleans(...))&#x60;
     *  - *Speed optimalization*: It is recommended to use &#x60;textContent&#x60; (instead of &#x60;innerText&#x60;) and &#x60;$dom.add&#x60; or &#x60;$dom.component&#x60; (instead of &#x60;innerHTML&#x60;).
     * @example
     *      const el= document.body;
     *      const onclick= function(){ console.log(this.dataset.js_param); };
     *      $dom.assign(el, { textContent: &quot;BODY&quot;, style: &quot;color: red;&quot;, dataset: { js_param: &quot;CLICKED&quot; }, onclick });
     *      //result HTML: &lt;body style=&quot;color: red;&quot; data-js_param=&quot;CLICKED&quot;&gt;BODY&lt;/body&gt;
     *      //console output on click: &quot;CLICKED&quot;
     *      $dom.assign(el, { classList: { testClass: -1 } });
     *      //result HTML: &lt;body class=&quot;testClass&quot; style=&quot;color: red;&quot; data-js_param=&quot;CLICKED&quot;&gt;BODY&lt;/body&gt;
     *      $dom.assign(el, { classList: { testClass: -1 } });
     *      //result HTML: &lt;body class=&quot;&quot; style=&quot;color: red;&quot; data-js_param=&quot;CLICKED&quot;&gt;BODY&lt;/body&gt;
     *      $dom.assign(el, { classList: { testClass: true } });//or 1
     *      //result HTML: &lt;body class=&quot;testClass&quot; style=&quot;color: red;&quot; data-js_param=&quot;CLICKED&quot;&gt;BODY&lt;/body&gt;
     *      //...
     */
    $dom.assign= function(element, object_attributes){
        const object_attributes_keys= Object.keys(object_attributes);
        for(let i=0, key, attr, i_length= object_attributes_keys.length; i&lt;i_length; i++){
            key= object_attributes_keys[i];
            attr= object_attributes[key];
            if(typeof attr===&quot;undefined&quot;){ if(element[key]){ delete element[key]; } continue; }
            switch(key){
                case &quot;style&quot;:
                    if(typeof attr===&quot;string&quot;) element.setAttribute(&quot;style&quot;, attr);
                    else for(let k=0, k_key, k_keys= Object.keys(attr), k_length= k_keys.length; k&lt;k_length; k++){ k_key= k_keys[k]; element.style.setProperty(k_key, attr[k_key]); }
                    break;
                case &quot;style_vars&quot;:
                    for(let k=0, k_key, k_keys= Object.keys(attr), k_length= k_keys.length; k&lt;k_length; k++){ k_key= k_keys[k]; element.style.setProperty(k_key, attr[k_key]); }
                    break;
                case &quot;classList&quot;:
                    if(!element[key].toggle) break;
                    for(let k=0, k_key, k_attr, k_keys= Object.keys(attr), k_length= k_keys.length; k&lt;k_length; k++){
                        k_key= k_keys[k]; k_attr= attr[k_key];
                        if(k_attr===-1) element.classList.toggle(k_key);
                        else element.classList.toggle(k_key, Boolean(k_attr));
                    }
                    break;
                case &quot;dataset&quot;:
                    for(let k=0, k_key, k_keys= Object.keys(attr), k_length= k_keys.length; k&lt;k_length; k++){ k_key= k_keys[k]; element.dataset[k_key]= attr[k_key]; }
                    break;
                case &quot;href&quot; || &quot;src&quot; || &quot;class&quot;:
                    element.setAttribute(key, attr);
                    break;
                default:
                    element[key]= attr;
                    break;
            }
        }
    };
    global.$dom= $dom;
}

</pre>

</div>
        </div>
    </div>
</div>
<script src="../assets/vendor/prettify/prettify-min.js"></script>
<script>prettyPrint();</script>
<script src="../assets/js/yui-prettify.js"></script>

</body>
</html>
